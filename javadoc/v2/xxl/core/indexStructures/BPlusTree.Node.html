<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_23) on Tue Jun 28 13:36:54 CEST 2011 -->
<TITLE>
BPlusTree.Node
</TITLE>

<META NAME="date" CONTENT="2011-06-28">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="BPlusTree.Node";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BPlusTree.Node.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../xxl/core/indexStructures/BPlusTree.KeyRange.html" title="class in xxl.core.indexStructures"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.MergeInfo.html" title="class in xxl.core.indexStructures"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?xxl/core/indexStructures/BPlusTree.Node.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="BPlusTree.Node.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
xxl.core.indexStructures</FONT>
<BR>
Class BPlusTree.Node</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">xxl.core.indexStructures.Tree.Node</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>xxl.core.indexStructures.BPlusTree.Node</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../xxl/core/indexStructures/HilbertRTree.Node.html" title="class in xxl.core.indexStructures">HilbertRTree.Node</A>, <A HREF="../../../xxl/core/indexStructures/MVBTree.Node.html" title="class in xxl.core.indexStructures">MVBTree.Node</A></DD>
</DL>
<DL>
<DT><B>Enclosing class:</B><DD><A HREF="../../../xxl/core/indexStructures/BPlusTree.html" title="class in xxl.core.indexStructures">BPlusTree</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>BPlusTree.Node</B><DT>extends <A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></DL>
</PRE>

<P>
This class is used to represent leaf- and non-leaf nodes of a
 <tt>BPlusTree</tt>. A <tt>Node</tt> contains a List of entries (data
 objects or <tt>IndexEntries</tt>). All <tt>Nodes</tt> are stored in
 <tt>Containers</tt>. 
 NOTE: if the tree is running in non-duplicate mode, the indexEntry descriptor
 holds the value of the left most element. In duplicate mode it is the right most
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.MergeInfo.html" title="class in xxl.core.indexStructures">BPlusTree.Node.MergeInfo</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A <tt>MergeInfo</tt> contains information about a merge (or
 redistribution).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.SplitInfo.html" title="class in xxl.core.indexStructures">BPlusTree.Node.SplitInfo</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A <tt>SplitInfo</tt> contains information about a split.</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../xxl/core/functions/Function.html" title="interface in xxl.core.functions">Function</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#createEntryList">createEntryList</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A <tt>Function</tt> to create the entries list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#entries">entries</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A <tt>List</tt> to hold the entries of the <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#nextNeighbor">nextNeighbor</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is a reference to the <tt>Node</tt> containing the smallest
 key which is larger than all keys stored in the subtree of this
 <tt>Node</tt>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_xxl.core.indexStructures.Tree.Node"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class xxl.core.indexStructures.<A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#level">level</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#BPlusTree.Node(int)">BPlusTree.Node</A></B>(int&nbsp;level)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <tt>Node</tt> on a given level.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#BPlusTree.Node(int, xxl.core.functions.Function)">BPlusTree.Node</A></B>(int&nbsp;level,
               <A HREF="../../../xxl/core/functions/Function.html" title="interface in xxl.core.functions">Function</A>&nbsp;createEntryList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <tt>Node</tt> on a given level.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#adjustSeparatorValue(xxl.core.indexStructures.BPlusTree.Node, xxl.core.indexStructures.BPlusTree.IndexEntry, java.util.Stack)">adjustSeparatorValue</A></B>(<A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html" title="class in xxl.core.indexStructures">BPlusTree.Node</A>&nbsp;node,
                     <A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A>&nbsp;indexEntry,
                     java.util.Stack&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ensures the separator value is updated, when last element is deleted</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#binarySearch(java.lang.Comparable)">binarySearch</A></B>(java.lang.Comparable&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the given key in this <tt>Node</tt> using the binary
 search algorithm on a sorted list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../xxl/core/indexStructures/Tree.IndexEntry.html" title="class in xxl.core.indexStructures">Tree.IndexEntry</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#chooseSubtree(xxl.core.indexStructures.Descriptor, java.util.Stack)">chooseSubtree</A></B>(<A HREF="../../../xxl/core/indexStructures/Descriptor.html" title="interface in xxl.core.indexStructures">Descriptor</A>&nbsp;descriptor,
              java.util.Stack&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Chooses the subtree which is followed during an insertion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Iterator</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#descriptors(xxl.core.indexStructures.Descriptor)">descriptors</A></B>(<A HREF="../../../xxl/core/indexStructures/Descriptor.html" title="interface in xxl.core.indexStructures">Descriptor</A>&nbsp;nodeDescriptor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives an <tt>Iterator</tt> pointing to the <tt>Descriptors</tt>
 of each entry in this <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Iterator</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#entries()">entries</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives an <tt>Iterator</tt> pointing to all entries stored in this
 <tt>Node</tt></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#getEntry(int)">getEntry</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives the entry stored on the given position in the <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#getFirst()">getFirst</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives the first entry of the <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#getLast()">getLast</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives the last entry of the <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#grow(java.lang.Object)">grow</A></B>(java.lang.Object&nbsp;entry)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserts a new entry into this <tt>Node</tt> at the suitable
 position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#grow(java.lang.Object, java.util.Stack)">grow</A></B>(java.lang.Object&nbsp;entry,
     java.util.Stack&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserts an entry into the current <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html" title="class in xxl.core.indexStructures">BPlusTree.Node</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#initialize(int, java.util.List)">initialize</A></B>(int&nbsp;level,
           java.util.List&nbsp;entries)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be used  for bulk loading or insertion</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../xxl/core/indexStructures/Tree.Node.SplitInfo.html" title="class in xxl.core.indexStructures">Tree.Node.SplitInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#initialize(java.lang.Object)">initialize</A></B>(java.lang.Object&nbsp;entry)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes the <tt>Node</tt> and inserts a new entry into it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Iterator</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#iterator()">iterator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives an <tt>Iterator</tt> pointing to all entries stored in this
 <tt>Node</tt></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#leftMostSearch(java.util.List, int, java.lang.Comparable)">leftMostSearch</A></B>(java.util.List&nbsp;entryList,
               int&nbsp;index,
               java.lang.Comparable&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;required for duplicate mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.MergeInfo.html" title="class in xxl.core.indexStructures">BPlusTree.Node.MergeInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#merge(xxl.core.indexStructures.BPlusTree.IndexEntry, java.util.Stack)">merge</A></B>(<A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A>&nbsp;indexEntry,
      java.util.Stack&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used to redistribute the elements of the underflowing <tt>Node</tt>
 from a suitable sibling or to merge them so that the underflow is
 repaired.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#nextNeighbor()">nextNeighbor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives the next neighbor of this <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#number()">number</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives the number of entries which are currently stored in this
 <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#post(xxl.core.indexStructures.Tree.Node.SplitInfo, xxl.core.indexStructures.Tree.IndexEntry)">post</A></B>(<A HREF="../../../xxl/core/indexStructures/Tree.Node.SplitInfo.html" title="class in xxl.core.indexStructures">Tree.Node.SplitInfo</A>&nbsp;splitInfo,
     <A HREF="../../../xxl/core/indexStructures/Tree.IndexEntry.html" title="class in xxl.core.indexStructures">Tree.IndexEntry</A>&nbsp;newIndexEntry)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Posts the <tt>SplitInfo</tt> from the child <tt>Nodes</tt> to the
 current <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Iterator</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#query(xxl.core.indexStructures.Descriptor)">query</A></B>(<A HREF="../../../xxl/core/indexStructures/Descriptor.html" title="interface in xxl.core.indexStructures">Descriptor</A>&nbsp;queryDescriptor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an <tt>Iterator</tt> of entries whose <tt>Separators</tt>
 overlap with the <tt>queryDescriptor</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#redistributeNode(java.util.Stack)">redistributeNode</A></B>(java.util.Stack&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method searches the right sibling node for a possible insertion point, 
 will be successful when right sibling is not full.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Collection</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#redressOverflow(java.util.Stack, java.util.List, boolean)">redressOverflow</A></B>(java.util.Stack&nbsp;path,
                java.util.List&nbsp;newIndexEntries,
                boolean&nbsp;up)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treats overflows which occur during an insertion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../xxl/core/indexStructures/Tree.Node.SplitInfo.html" title="class in xxl.core.indexStructures">Tree.Node.SplitInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#redressOverflow(java.util.Stack, xxl.core.indexStructures.Tree.Node, java.util.List)">redressOverflow</A></B>(java.util.Stack&nbsp;path,
                <A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A>&nbsp;parentNode,
                java.util.List&nbsp;newIndexEntries)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treats overflows which occur during an insertion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#redressUnderflow(xxl.core.indexStructures.BPlusTree.IndexEntry, xxl.core.indexStructures.BPlusTree.Node, java.util.Stack, boolean)">redressUnderflow</A></B>(<A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A>&nbsp;indexEntry,
                 <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html" title="class in xxl.core.indexStructures">BPlusTree.Node</A>&nbsp;node,
                 java.util.Stack&nbsp;path,
                 boolean&nbsp;up)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treats underflows which occur during a remove operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#redressUnderflow(java.util.Stack)">redressUnderflow</A></B>(java.util.Stack&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treats underflows which occur during a remove operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#redressUnderflow(java.util.Stack, boolean)">redressUnderflow</A></B>(java.util.Stack&nbsp;path,
                 boolean&nbsp;up)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treats underflows which occur during a remove operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#remove(xxl.core.indexStructures.BPlusTree.IndexEntry)">remove</A></B>(<A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A>&nbsp;indexEntry)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the given <tt>IndexEntry</tt> and removes it from this
 <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#remove(int)">remove</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the entry stored in the <tt>Node</tt> on the given
 position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#rightMostSearch(java.lang.Comparable)">rightMostSearch</A></B>(java.lang.Comparable&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;required for duplicate mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#search(xxl.core.indexStructures.BPlusTree.IndexEntry)">search</A></B>(<A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A>&nbsp;indexEntry)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the given <tt>IndexEntry</tt> in this <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#search(java.lang.Comparable)">search</A></B>(java.lang.Comparable&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the given key in this <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#search(xxl.core.indexStructures.Separator)">search</A></B>(<A HREF="../../../xxl/core/indexStructures/Separator.html" title="class in xxl.core.indexStructures">Separator</A>&nbsp;separator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the given <tt>Separator</tt> in this <tt>Node</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../xxl/core/indexStructures/Tree.Node.SplitInfo.html" title="class in xxl.core.indexStructures">Tree.Node.SplitInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#split(java.util.Stack)">split</A></B>(java.util.Stack&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splits the overflowed node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_xxl.core.indexStructures.Tree.Node"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class xxl.core.indexStructures.<A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#chooseSubtree(xxl.core.indexStructures.Descriptor, java.util.Stack, xxl.core.functions.Function)">chooseSubtree</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#chooseSubtree(xxl.core.indexStructures.Descriptor, java.util.Stack, xxl.core.predicates.Predicate)">chooseSubtree</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#chooseSubtree(java.lang.Object, java.util.Stack)">chooseSubtree</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#chooseSubtree(java.lang.Object, java.util.Stack, xxl.core.functions.Function)">chooseSubtree</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#chooseSubtree(java.lang.Object, java.util.Stack, xxl.core.predicates.Predicate)">chooseSubtree</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#initialize(int)">initialize</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#level()">level</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#overflows()">overflows</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#redressOverflow(java.util.Stack)">redressOverflow</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#redressOverflow(java.util.Stack, boolean)">redressOverflow</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#redressOverflow(java.util.Stack, java.util.List)">redressOverflow</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#splitMaxNumber()">splitMaxNumber</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#splitMaxRatio()">splitMaxRatio</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#splitMinNumber()">splitMinNumber</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#splitMinRatio()">splitMinRatio</A>, <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#underflows()">underflows</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="entries"><!-- --></A><H3>
entries</H3>
<PRE>
protected java.util.List <B>entries</B></PRE>
<DL>
<DD>A <tt>List</tt> to hold the entries of the <tt>Node</tt>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nextNeighbor"><!-- --></A><H3>
nextNeighbor</H3>
<PRE>
public <A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A> <B>nextNeighbor</B></PRE>
<DL>
<DD>This is a reference to the <tt>Node</tt> containing the smallest
 key which is larger than all keys stored in the subtree of this
 <tt>Node</tt>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="createEntryList"><!-- --></A><H3>
createEntryList</H3>
<PRE>
protected <A HREF="../../../xxl/core/functions/Function.html" title="interface in xxl.core.functions">Function</A> <B>createEntryList</B></PRE>
<DL>
<DD>A <tt>Function</tt> to create the entries list. That makes the
 <tt>Node</tt> more flexible, because it can use any implementation
 of the abstract interface <CODE>List</CODE>.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="BPlusTree.Node(int, xxl.core.functions.Function)"><!-- --></A><H3>
BPlusTree.Node</H3>
<PRE>
public <B>BPlusTree.Node</B>(int&nbsp;level,
                      <A HREF="../../../xxl/core/functions/Function.html" title="interface in xxl.core.functions">Function</A>&nbsp;createEntryList)</PRE>
<DL>
<DD>Creates a new <tt>Node</tt> on a given level.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>level</CODE> - the level of the new <tt>Node</tt><DD><CODE>createEntryList</CODE> - a factory <tt>Function</tt> to create the entries list<DT><B>See Also:</B><DD><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#createEntryList"><CODE>createEntryList</CODE></A></DL>
</DL>
<HR>

<A NAME="BPlusTree.Node(int)"><!-- --></A><H3>
BPlusTree.Node</H3>
<PRE>
public <B>BPlusTree.Node</B>(int&nbsp;level)</PRE>
<DL>
<DD>Creates a new <tt>Node</tt> on a given level. An
 <CODE>ArrayList</CODE>is used to store the entries.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>level</CODE> - the level of the new <tt>Node</tt></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="initialize(java.lang.Object)"><!-- --></A><H3>
initialize</H3>
<PRE>
protected <A HREF="../../../xxl/core/indexStructures/Tree.Node.SplitInfo.html" title="class in xxl.core.indexStructures">Tree.Node.SplitInfo</A> <B>initialize</B>(java.lang.Object&nbsp;entry)</PRE>
<DL>
<DD>Initializes the <tt>Node</tt> and inserts a new entry into it.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#initialize(java.lang.Object)">initialize</A></CODE> in class <CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>entry</CODE> - the entry which has to be inserted
<DT><B>Returns:</B><DD><tt>SplitInfo</tt> which contains information about a
         possible split</DL>
</DD>
</DL>
<HR>

<A NAME="initialize(int, java.util.List)"><!-- --></A><H3>
initialize</H3>
<PRE>
public <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html" title="class in xxl.core.indexStructures">BPlusTree.Node</A> <B>initialize</B>(int&nbsp;level,
                                 java.util.List&nbsp;entries)</PRE>
<DL>
<DD>This method can be used  for bulk loading or insertion
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>level</CODE> - <DD><CODE>entries</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="nextNeighbor()"><!-- --></A><H3>
nextNeighbor</H3>
<PRE>
public <A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A> <B>nextNeighbor</B>()</PRE>
<DL>
<DD>Gives the next neighbor of this <tt>Node</tt>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the next neighbor of this <tt>Node</tt><DT><B>See Also:</B><DD><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#nextNeighbor"><CODE>nextNeighbor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getEntry(int)"><!-- --></A><H3>
getEntry</H3>
<PRE>
public java.lang.Object <B>getEntry</B>(int&nbsp;index)</PRE>
<DL>
<DD>Gives the entry stored on the given position in the <tt>Node</tt>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - the position of the required entry
<DT><B>Returns:</B><DD>the entry stored on the given position in the <tt>Node</tt>
         or <tt>null</tt> if the <tt>Node</tt> is empty</DL>
</DD>
</DL>
<HR>

<A NAME="getLast()"><!-- --></A><H3>
getLast</H3>
<PRE>
public java.lang.Object <B>getLast</B>()</PRE>
<DL>
<DD>Gives the last entry of the <tt>Node</tt>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the last entry of the <tt>Node</tt> or <tt>null</tt> if
         the <tt>Node</tt> is empty</DL>
</DD>
</DL>
<HR>

<A NAME="getFirst()"><!-- --></A><H3>
getFirst</H3>
<PRE>
public java.lang.Object <B>getFirst</B>()</PRE>
<DL>
<DD>Gives the first entry of the <tt>Node</tt>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the first entry of the <tt>Node</tt> or <tt>null</tt> if
         the <tt>Node</tt> is empty</DL>
</DD>
</DL>
<HR>

<A NAME="number()"><!-- --></A><H3>
number</H3>
<PRE>
public int <B>number</B>()</PRE>
<DL>
<DD>Gives the number of entries which are currently stored in this
 <tt>Node</tt>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#number()">number</A></CODE> in class <CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the number of entries which are currently stored in this
         <tt>Node</tt></DL>
</DD>
</DL>
<HR>

<A NAME="entries()"><!-- --></A><H3>
entries</H3>
<PRE>
public java.util.Iterator <B>entries</B>()</PRE>
<DL>
<DD>Gives an <tt>Iterator</tt> pointing to all entries stored in this
 <tt>Node</tt>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#entries()">entries</A></CODE> in class <CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>an <tt>Iterator</tt> pointing to all entries stored in this
         <tt>Node</tt></DL>
</DD>
</DL>
<HR>

<A NAME="iterator()"><!-- --></A><H3>
iterator</H3>
<PRE>
protected java.util.Iterator <B>iterator</B>()</PRE>
<DL>
<DD>Gives an <tt>Iterator</tt> pointing to all entries stored in this
 <tt>Node</tt>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an <tt>Iterator</tt> pointing to all entries stored in this
         <tt>Node</tt></DL>
</DD>
</DL>
<HR>

<A NAME="descriptors(xxl.core.indexStructures.Descriptor)"><!-- --></A><H3>
descriptors</H3>
<PRE>
public java.util.Iterator <B>descriptors</B>(<A HREF="../../../xxl/core/indexStructures/Descriptor.html" title="interface in xxl.core.indexStructures">Descriptor</A>&nbsp;nodeDescriptor)</PRE>
<DL>
<DD>Gives an <tt>Iterator</tt> pointing to the <tt>Descriptors</tt>
 of each entry in this <tt>Node</tt>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#descriptors(xxl.core.indexStructures.Descriptor)">descriptors</A></CODE> in class <CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeDescriptor</CODE> - the descriptor of this <tt>Node</tt>
<DT><B>Returns:</B><DD>an <tt>Iterator</tt> pointing to the <tt>Descriptors</tt>
         of each entry in this <tt>Node</tt></DL>
</DD>
</DL>
<HR>

<A NAME="query(xxl.core.indexStructures.Descriptor)"><!-- --></A><H3>
query</H3>
<PRE>
public java.util.Iterator <B>query</B>(<A HREF="../../../xxl/core/indexStructures/Descriptor.html" title="interface in xxl.core.indexStructures">Descriptor</A>&nbsp;queryDescriptor)</PRE>
<DL>
<DD>Returns an <tt>Iterator</tt> of entries whose <tt>Separators</tt>
 overlap with the <tt>queryDescriptor</tt>.
 Initialization of  minIndex and maxIndex  similar to    
 <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#chooseSubtree(xxl.core.indexStructures.Descriptor, java.util.Stack)"><CODE>chooseSubtree(Descriptor descriptor,
                Stack path)</CODE></A>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#query(xxl.core.indexStructures.Descriptor)">query</A></CODE> in class <CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>queryDescriptor</CODE> - the <tt>KeyRange</tt> describing the query
<DT><B>Returns:</B><DD>an <tt>Iterator</tt> of entries whose <tt>Separators</tt>
         overlap with the <tt>queryDescriptor</tt></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(java.lang.Comparable)"><!-- --></A><H3>
binarySearch</H3>
<PRE>
protected int <B>binarySearch</B>(java.lang.Comparable&nbsp;key)</PRE>
<DL>
<DD>Searches the given key in this <tt>Node</tt> using the binary
 search algorithm on a sorted list.
 NOTE: if running in duplicate mode left most duplicate value will be 
 returned
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key which is to search in this <tt>Node</tt>
<DT><B>Returns:</B><DD>the position of the key if it was found or its insertion
         position in the list otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="leftMostSearch(java.util.List, int, java.lang.Comparable)"><!-- --></A><H3>
leftMostSearch</H3>
<PRE>
protected int <B>leftMostSearch</B>(java.util.List&nbsp;entryList,
                             int&nbsp;index,
                             java.lang.Comparable&nbsp;key)</PRE>
<DL>
<DD>required for duplicate mode. Left most search of duplicate value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>entryList</CODE> - <DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>the position of the left most duplicate value</DL>
</DD>
</DL>
<HR>

<A NAME="rightMostSearch(java.lang.Comparable)"><!-- --></A><H3>
rightMostSearch</H3>
<PRE>
protected int <B>rightMostSearch</B>(java.lang.Comparable&nbsp;key)</PRE>
<DL>
<DD>required for duplicate mode. Right most search of duplicate value.
<P>
<DD><DL>

<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="search(java.lang.Comparable)"><!-- --></A><H3>
search</H3>
<PRE>
protected int <B>search</B>(java.lang.Comparable&nbsp;key)</PRE>
<DL>
<DD>Searches the given key in this <tt>Node</tt>. The default
 implementation simply calls the method
 <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#binarySearch(java.lang.Comparable)"><CODE>binarySearch(Comparable)</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key which is to search in this <tt>Node</tt>
<DT><B>Returns:</B><DD>the position of the key if it was found or its insertion
         position in the list otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="search(xxl.core.indexStructures.Separator)"><!-- --></A><H3>
search</H3>
<PRE>
protected int <B>search</B>(<A HREF="../../../xxl/core/indexStructures/Separator.html" title="class in xxl.core.indexStructures">Separator</A>&nbsp;separator)</PRE>
<DL>
<DD>Searches the given <tt>Separator</tt> in this <tt>Node</tt>. The
 default implementation takes the separation value of the given
 <tt>Separator</tt> and searches for it using the method
 <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#search(java.lang.Comparable)"><CODE>search(Comparable)</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>separator</CODE> - the <tt>Separator</tt> which is to search in this
            <tt>Node</tt>
<DT><B>Returns:</B><DD>the position of the <tt>Separator</tt> if it was found or
         its insertion position in the list otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="search(xxl.core.indexStructures.BPlusTree.IndexEntry)"><!-- --></A><H3>
search</H3>
<PRE>
protected int <B>search</B>(<A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A>&nbsp;indexEntry)</PRE>
<DL>
<DD>Searches the given <tt>IndexEntry</tt> in this <tt>Node</tt>.
 The default implementation takes the <tt>Separator</tt> of the
 given <tt>IndexEntry</tt> and searches for it using the method
 <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#search(xxl.core.indexStructures.Separator)"><CODE>search(Separator)</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>indexEntry</CODE> - the <tt>IndexEntry</tt> which is to search in this
            <tt>Node</tt>
<DT><B>Returns:</B><DD>the position of the <tt>IndexEntry</tt> if it was found or
         its insertion position in the list otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="chooseSubtree(xxl.core.indexStructures.Descriptor, java.util.Stack)"><!-- --></A><H3>
chooseSubtree</H3>
<PRE>
protected <A HREF="../../../xxl/core/indexStructures/Tree.IndexEntry.html" title="class in xxl.core.indexStructures">Tree.IndexEntry</A> <B>chooseSubtree</B>(<A HREF="../../../xxl/core/indexStructures/Descriptor.html" title="interface in xxl.core.indexStructures">Descriptor</A>&nbsp;descriptor,
                                        java.util.Stack&nbsp;path)</PRE>
<DL>
<DD>Chooses the subtree which is followed during an insertion.
 
 In duplicate mode the minIndex is evaluated to positve when with a successful search
 or negative when the value separator is not found, this negative value points to the 
 position in the list where the new item should be inserted. when this position lies 
 at the end of the list a special case is used to correct the value.
 In normal mode for negative values of minIndex the item must be inserted before the 
 item at the position pointed at by the returned value.
 <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#binarySearch(java.lang.Comparable)"><CODE>binarySearch(Comparable)</CODE></A>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#chooseSubtree(xxl.core.indexStructures.Descriptor, java.util.Stack)">chooseSubtree</A></CODE> in class <CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>descriptor</CODE> - the <tt>Separator</tt> of the entry which is to insert<DD><CODE>path</CODE> - the path from the root to this <tt>Node</tt>. The
            default implementation does not use this path
<DT><B>Returns:</B><DD>the <tt>IndexEntry</tt> pointing to the subtree which is
         followed during an insertion</DL>
</DD>
</DL>
<HR>

<A NAME="post(xxl.core.indexStructures.Tree.Node.SplitInfo, xxl.core.indexStructures.Tree.IndexEntry)"><!-- --></A><H3>
post</H3>
<PRE>
protected void <B>post</B>(<A HREF="../../../xxl/core/indexStructures/Tree.Node.SplitInfo.html" title="class in xxl.core.indexStructures">Tree.Node.SplitInfo</A>&nbsp;splitInfo,
                    <A HREF="../../../xxl/core/indexStructures/Tree.IndexEntry.html" title="class in xxl.core.indexStructures">Tree.IndexEntry</A>&nbsp;newIndexEntry)</PRE>
<DL>
<DD>Posts the <tt>SplitInfo</tt> from the child <tt>Nodes</tt> to the
 current <tt>Node</tt>. The method inserts the new
 <tt>IndexEntry</tt> into the <tt>Node</tt> using the method
 <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#grow(java.lang.Object, java.util.Stack)"><CODE>grow(Object, Stack)</CODE></A>. It gets the path from
 the given <tt>SplitInfo</tt>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#post(xxl.core.indexStructures.Tree.Node.SplitInfo, xxl.core.indexStructures.Tree.IndexEntry)">post</A></CODE> in class <CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>splitInfo</CODE> - contains the information about the split which led to
            create the new <tt>IndexEntry</tt><DD><CODE>newIndexEntry</CODE> - the new <tt>IndexEntry</tt> created by the split<DT><B>See Also:</B><DD><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#grow(java.lang.Object, java.util.Stack)"><CODE>grow(Object, Stack)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="grow(java.lang.Object, java.util.Stack)"><!-- --></A><H3>
grow</H3>
<PRE>
protected void <B>grow</B>(java.lang.Object&nbsp;entry,
                    java.util.Stack&nbsp;path)</PRE>
<DL>
<DD>Inserts an entry into the current <tt>Node</tt>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#grow(java.lang.Object, java.util.Stack)">grow</A></CODE> in class <CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>entry</CODE> - the entry which has to be inserted into the node<DD><CODE>path</CODE> - the path from the root to the current node. The default
            Implementation does not use this path<DT><B>See Also:</B><DD><A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#grow(java.lang.Object)"><CODE>grow(Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="grow(java.lang.Object)"><!-- --></A><H3>
grow</H3>
<PRE>
protected void <B>grow</B>(java.lang.Object&nbsp;entry)</PRE>
<DL>
<DD>Inserts a new entry into this <tt>Node</tt> at the suitable
 position. The position is found using a binary search.
 <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#binarySearch(java.lang.Comparable)"><CODE>binarySearch(Comparable)</CODE></A>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>entry</CODE> - the new entry which has to be inserted
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - in normal mode if the key already exists in the node.</DL>
</DD>
</DL>
<HR>

<A NAME="redressOverflow(java.util.Stack, java.util.List, boolean)"><!-- --></A><H3>
redressOverflow</H3>
<PRE>
protected java.util.Collection <B>redressOverflow</B>(java.util.Stack&nbsp;path,
                                               java.util.List&nbsp;newIndexEntries,
                                               boolean&nbsp;up)</PRE>
<DL>
<DD>Treats overflows which occur during an insertion. 
 It splits the overflowing node in new nodes. It creates new index-entries 
 for the new nodes. These index-entries will be be added to the given <tt>List</tt>. If the Leaf Node 
 is found to be full, <CODE>BPlusTree.Node#redistributeLeaf(IndexEntry currentEntry, Node parentNode, IndexEntry parentIndex )</CODE> 
 is attempted to avoid a split.
 The method <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#post(xxl.core.indexStructures.Tree.Node.SplitInfo, xxl.core.indexStructures.Tree.IndexEntry)"><CODE>post(Tree.Node.SplitInfo, Tree.IndexEntry)</CODE></A> will later be used to post the 
 created index-entries to the parent node.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#redressOverflow(java.util.Stack, java.util.List, boolean)">redressOverflow</A></CODE> in class <CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the path from the root to the overflowing node<DD><CODE>newIndexEntries</CODE> - a <tt>List</tt> to carry the new index-entries created by the split<DD><CODE>up</CODE> - signals whether the top node on stack will be written into the 
 storage by calling <A HREF="../../../xxl/core/indexStructures/Tree.html#update(java.util.Stack)"><CODE>Tree.update(Stack path)</CODE></A> and unfixed from the underlying buffer 
 by calling <A HREF="../../../xxl/core/indexStructures/Tree.html#up(java.util.Stack)"><CODE>Tree.up(Stack path)</CODE></A>.
<DT><B>Returns:</B><DD>a Collection which accrues from the given collection and the created 
 index-entries during the split.</DL>
</DD>
</DL>
<HR>

<A NAME="redressOverflow(java.util.Stack, xxl.core.indexStructures.Tree.Node, java.util.List)"><!-- --></A><H3>
redressOverflow</H3>
<PRE>
protected <A HREF="../../../xxl/core/indexStructures/Tree.Node.SplitInfo.html" title="class in xxl.core.indexStructures">Tree.Node.SplitInfo</A> <B>redressOverflow</B>(java.util.Stack&nbsp;path,
                                              <A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A>&nbsp;parentNode,
                                              java.util.List&nbsp;newIndexEntries)</PRE>
<DL>
<DD>Treats overflows which occur during an insertion. The method
 <A HREF="../../../xxl/core/indexStructures/Tree.Node.html#redressOverflow(java.util.Stack, xxl.core.indexStructures.Tree.Node, java.util.List)"><CODE>Tree.Node.redressOverflow(Stack, xxl.core.indexStructures.Tree.Node, List)</CODE></A>
 of the super class is used to split the overflowing <tt>Node</tt>
 in two <tt>Nodes</tt>. It creates a new <tt>IndexEntry</tt> for
 the new <tt>Node</tt>. This <tt>IndexEntry</tt> will be added to
 the given List. 
 Finally the new <tt>Node</tt> is linked
 from the split <tt>Node</tt> as <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#nextNeighbor"><CODE>nextNeighbor</CODE></A>.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#redressOverflow(java.util.Stack, xxl.core.indexStructures.Tree.Node, java.util.List)">redressOverflow</A></CODE> in class <CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the path from the root to the overflowing <tt>Node</tt><DD><CODE>parentNode</CODE> - the parent <tt>Node</tt> of the overflowing
            <tt>Node</tt><DD><CODE>newIndexEntries</CODE> - a List to carry the new <tt>IndexEntries</tt> created by
            the split
<DT><B>Returns:</B><DD>a <tt>SplitInfo</tt> containing required information about
         the split</DL>
</DD>
</DL>
<HR>

<A NAME="redistributeNode(java.util.Stack)"><!-- --></A><H3>
redistributeNode</H3>
<PRE>
protected boolean <B>redistributeNode</B>(java.util.Stack&nbsp;path)</PRE>
<DL>
<DD>This method searches the right sibling node for a possible insertion point, 
 will be successful when right sibling is not full. 
 The method is reserved for improved BPlusTree. 
 In this implementation this method returns always false
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>currentEntry</CODE> - <DD><CODE>parentNode</CODE> - 
<DT><B>Returns:</B><DD>true when redistribution succeed</DL>
</DD>
</DL>
<HR>

<A NAME="split(java.util.Stack)"><!-- --></A><H3>
split</H3>
<PRE>
protected <A HREF="../../../xxl/core/indexStructures/Tree.Node.SplitInfo.html" title="class in xxl.core.indexStructures">Tree.Node.SplitInfo</A> <B>split</B>(java.util.Stack&nbsp;path)</PRE>
<DL>
<DD>Splits the overflowed node. In non duplicate mode both the leaf and index nodes 
 are splited in the middle. In duplicate mode the leaf nodes are splited 
 according following strategy:  
 with leaf nodes the last element is selected and checked against 
 the the element at 75% position, when both are equal search for further duplicates until 25% reached
 or no more duplicates exists, then split at found index position, otherwise split in the middle.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html#split(java.util.Stack)">split</A></CODE> in class <CODE><A HREF="../../../xxl/core/indexStructures/Tree.Node.html" title="class in xxl.core.indexStructures">Tree.Node</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - 
<DT><B>Returns:</B><DD>a <tt>SplitInfo</tt> containing all needed information about
         the split</DL>
</DD>
</DL>
<HR>

<A NAME="remove(xxl.core.indexStructures.BPlusTree.IndexEntry)"><!-- --></A><H3>
remove</H3>
<PRE>
protected <A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A> <B>remove</B>(<A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A>&nbsp;indexEntry)</PRE>
<DL>
<DD>Searches the given <tt>IndexEntry</tt> and removes it from this
 <tt>Node</tt>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>indexEntry</CODE> - the <tt>IndexEntry</tt> which is to remove
<DT><B>Returns:</B><DD>the removed <tt>IndexEntry</tt> if it was found or
         <tt>null</tt> otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="remove(int)"><!-- --></A><H3>
remove</H3>
<PRE>
protected java.lang.Object <B>remove</B>(int&nbsp;index)</PRE>
<DL>
<DD>Removes the entry stored in the <tt>Node</tt> on the given
 position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - the position of the entry which is to be removed
<DT><B>Returns:</B><DD>the removed entry if the given position is valid or
         <tt>null</tt> otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="redressUnderflow(java.util.Stack)"><!-- --></A><H3>
redressUnderflow</H3>
<PRE>
protected boolean <B>redressUnderflow</B>(java.util.Stack&nbsp;path)</PRE>
<DL>
<DD>Treats underflows which occur during a remove operation. If the given
 path is empty an <tt>IllegalStateException</tt> is thrown, otherwise the
 method <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#redressUnderflow(java.util.Stack, boolean)"><CODE>redressUnderflow(Stack, boolean)</CODE></A>is
 called with the parameter path and <tt>true</tt> to repair the
 underflow.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the path from the root to the underflowing <tt>Node</tt>
<DT><B>Returns:</B><DD>a boolean which indicates whether the parent <tt>Node</tt>
         was updated during the operation</DL>
</DD>
</DL>
<HR>

<A NAME="redressUnderflow(java.util.Stack, boolean)"><!-- --></A><H3>
redressUnderflow</H3>
<PRE>
protected boolean <B>redressUnderflow</B>(java.util.Stack&nbsp;path,
                                   boolean&nbsp;up)</PRE>
<DL>
<DD>Treats underflows which occur during a remove operation. In case of
 underflow the method
 <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#redressUnderflow(java.util.Stack)"><CODE>(BPlusTree.IndexEntry, BPlusTree.Node, Stack, boolean)</CODE></A>
 is called to repair the underflow.
 When the root node has only one entry the root entry pointer is deleted and replaced with the 
 child node.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the path from the root to the underflowing <tt>Node</tt><DD><CODE>up</CODE> - signals whether the treated <tt>Nodes</tt> have to be
            updated in the underlying <tt>Container</tt>
<DT><B>Returns:</B><DD>a boolean which indicates whether the parent <tt>Node</tt>
         was been updated during the operation</DL>
</DD>
</DL>
<HR>

<A NAME="adjustSeparatorValue(xxl.core.indexStructures.BPlusTree.Node, xxl.core.indexStructures.BPlusTree.IndexEntry, java.util.Stack)"><!-- --></A><H3>
adjustSeparatorValue</H3>
<PRE>
protected boolean <B>adjustSeparatorValue</B>(<A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html" title="class in xxl.core.indexStructures">BPlusTree.Node</A>&nbsp;node,
                                       <A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A>&nbsp;indexEntry,
                                       java.util.Stack&nbsp;path)</PRE>
<DL>
<DD>Ensures the separator value is updated, when last element is deleted
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>current</CODE> - Node  <tt>Node</tt><DD><CODE>indexEntry</CODE> - the <tt>IndexEntry</tt> referring to the <tt>Node</tt><DD><CODE>path</CODE> - the path from the root to parent of the 
            <tt>Node</tt>
<DT><B>Returns:</B><DD>true when an update was completed, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="redressUnderflow(xxl.core.indexStructures.BPlusTree.IndexEntry, xxl.core.indexStructures.BPlusTree.Node, java.util.Stack, boolean)"><!-- --></A><H3>
redressUnderflow</H3>
<PRE>
protected boolean <B>redressUnderflow</B>(<A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A>&nbsp;indexEntry,
                                   <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html" title="class in xxl.core.indexStructures">BPlusTree.Node</A>&nbsp;node,
                                   java.util.Stack&nbsp;path,
                                   boolean&nbsp;up)</PRE>
<DL>
<DD>Treats underflows which occur during a remove operation. It calls the
 method <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.html#merge(xxl.core.indexStructures.BPlusTree.IndexEntry, java.util.Stack)"><CODE>merge(BPlusTree.IndexEntry, Stack)</CODE></A>to
 redistribute the elements of the underflowing <tt>Node</tt> an a
 suitable sibling or to merge them so that the underflow is repaired.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>indexEntry</CODE> - the <tt>IndexEntry</tt> referring to the underflowing
            <tt>Node</tt><DD><CODE>node</CODE> - the underflowing <tt>Node</tt><DD><CODE>path</CODE> - the path from the root to parent of the underflowing
            <tt>Node</tt><DD><CODE>up</CODE> - signals whether the treated <tt>Nodes</tt> have to be
            updated in the underlying <tt>Container</tt>
<DT><B>Returns:</B><DD>a boolean which indicate whether the parent <tt>Node</tt>
         was been updated during the operation</DL>
</DD>
</DL>
<HR>

<A NAME="merge(xxl.core.indexStructures.BPlusTree.IndexEntry, java.util.Stack)"><!-- --></A><H3>
merge</H3>
<PRE>
protected <A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.MergeInfo.html" title="class in xxl.core.indexStructures">BPlusTree.Node.MergeInfo</A> <B>merge</B>(<A HREF="../../../xxl/core/indexStructures/BPlusTree.IndexEntry.html" title="class in xxl.core.indexStructures">BPlusTree.IndexEntry</A>&nbsp;indexEntry,
                                         java.util.Stack&nbsp;path)</PRE>
<DL>
<DD>Used to redistribute the elements of the underflowing <tt>Node</tt>
 from a suitable sibling or to merge them so that the underflow is
 repaired.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>indexEntry</CODE> - the <tt>IndexEntry</tt> referring to the underflowing
            <tt>Node</tt><DD><CODE>path</CODE> - the path from the root to parent of the underflowing
            <tt>Node</tt>
<DT><B>Returns:</B><DD>a <tt>MergeInfo</tt> containing some information about the
         merge (or redistribution)</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BPlusTree.Node.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../xxl/core/indexStructures/BPlusTree.KeyRange.html" title="class in xxl.core.indexStructures"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../xxl/core/indexStructures/BPlusTree.Node.MergeInfo.html" title="class in xxl.core.indexStructures"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?xxl/core/indexStructures/BPlusTree.Node.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="BPlusTree.Node.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
